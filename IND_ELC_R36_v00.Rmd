---
title: "India Electric Power Sector model"
author: '@olugovoy'
date: "10/18/2019"
output:
  pdf_document: 
    toc: yes
    toc_depth: 5
  html_document:
    toc: yes
    toc_depth: 5
editor_options: 
  chunk_output_type: console
---
(WORK IN PROGRESS!)

# Changelog   
June 16, 2020   
- Added option to scale-down the model to several states (with Southern Zonal Council as an example)   

June 9, 2020  
- works with R 4.0.1 version (requires *energyRt* v0.1.10+)  

June 3, 2020:  
- updated maps  
- added scenarios (2x) with alternative specification of the grid  


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#knitr::opts_chunk$set(fig_width = 8, fig_height = 6)
library(energyRt)
library(lubridate)
library(tibble)
library(tidyverse)
library(sf)
source("solver_options.R")
# mySolver <- "GLPK" # not capable enough for large models
# mySolver <- "GAMS" # default LP solver will be used (CPLEX is recommended)

if (!dir.exists("fig")) dir.create("fig")
if (!dir.exists("scenarios")) dir.create("scenarios")
if (!dir.exists("tmp")) dir.create("tmp")

tmz <- "Asia/Kolkata" # model timezone
baseyear <- 2015 # model base year
myear <- 2050 # model year

model_regs <- NULL
# Optional - select regions for the model
if (F) { 
  selected_regions <- c("Andhra Pradesh", "Karnataka", "Kerala", 
                        # "Puducherry", 
                        # "West Bengal",
                        "Tamil Nadu", "Telangana")
  (load("data/maps/india_adm1_light.RData"))
  ii <- as.character(india_light_sp$NAME_1) %in% selected_regions 
  plot(india_light_sp)
  plot(india_light_sp[ii,], col = "red", add = TRUE)
  model_regs <- as.character(india_light_sp$region[ii])
}


```

# GIS info, map
```{r}
(load("data/maps/india_adm1_light.RData"))
length(india_light_sp) # number of regions (polygons)

if (is.null(model_regs)) {
  (load("data/model_regs.RData"))
}

# (reg_names <- unique(as.character(gis_sp@data$region)))
(reg_names <- unique(as.character(model_regs)))
(reg_names_in_gis <- as.character(india_light_sp@data$region))
gis_ii <- india_light_sp$region %in% model_regs

(nreg <- length(reg_names))
(nreg_in_gis <- length(india_light_sp@data$region))

gis_sp <- india_light_sp[gis_ii,]
gis_sf <- india_light_sf[gis_ii,]
gis_df <- fortify(gis_sp, region = "region") %>% as_tibble()

plot(gis_sf[, "region"], border = rgb(1,1,1,0.3), key.pos=NULL,
     main = paste(sum(gis_ii), "regions"))

# Neighbor regions
if (!any((installed.packages())[, "Package"] == "spdep")) install.packages("spdep")
# nbr <- spdep::poly2nb(gis_sp)
nbr <- spdep::poly2nb(india_light_sp, row.names = india_light_sp$region)
# names(nbr) <- gis_sp@data$region

# Centers of the regions
reg_centers <- getCenters(gis_sp)
reg_area <- tibble(
  region = reg_centers$region,
  area_km2 = raster::area(gis_sp) / 1e6
)

```


# Sub-annual time resolution (time-slices)   
  
Here we define two levels of time-slices:  
- the day of the year (*YDAY*), from 1 to 365;  
- the hour (1 to 24).  
Therefore we have 8760 time slices, named according to the format *"dNNN_hNN"*, where *N* - numbers.  

For convenience, let's define finctions to convert data-time into slices names and back.  

## 365 days * 24 hours (8760)  
```{r Time_slices_8760}
# A list with two levels slices
timeslices365 <- list(
  YDAY = paste0("d", formatC(1:365, width = 3, flag = "0")),
  HOUR = paste0("h", formatC(0:23, width = 2, flag = "0"))
)

# Function to convert data-time object into names of time-slices.
datetime2tsdh <- function(dt) {
  paste0("d", formatC(yday(dt), width = 3, flag = "0"), "_",
         "h", formatC(hour(dt), width = 2, flag = "0"))
}
# check
datetime2tsdh(today(tmz))

# Function to coerse time-slices names into data-time format, for a given year and time-zone.
tsdh2datetime <- function(tslice, year = 2050, tz = tmz) {
  DAY <- as.integer(substr(tslice, 2, 4)) - 1
  HOUR <- as.integer(substr(tslice, 7, 8))
  lubridate::ymd_h(paste0(year, "-01-01 0"), tz = tz) + days(DAY) + hours(HOUR)
}
# check
tsdh2datetime("d365_h23")

# data.frame object with names of the final time-slices in the model
#   and releted data-time information
slc365 <- tibble(
  slice = kronecker(timeslices365$YDAY, timeslices365$HOUR, FUN = "paste", sep = "_")
)
# add date-time info
slc365$syday <- substr(slc365$slice, 1, 4)
slc365$shour <- substr(slc365$slice, 6, 8)
slc365$yday <- as.integer(substr(slc365$slice, 2, 4))
slc365$hour <- as.integer(substr(slc365$slice, 7, 8))
slc365$datetime <- tsdh2datetime(slc365$slice)
slc365$month <- month(slc365$datetime)
slc365$week <- week(slc365$datetime)
head(slc365)
tail(slc365)


```

## 12 months * 24 hours (288)
```{r Time_slices_m12h}

timeslices_m12 <- list(
  ANNUAL = "ANNUAL", # this name is fixed, should not be changes
  MONTH = paste0("m", formatC(1:12, width = 2, flag = "0")),
  HOUR = paste0("h", formatC(0:23, width = 2, flag = "0"))
)

# # Function to convert data-time object into names of time-slices.
# datetime2tsdh <- function(dt) {
#   paste0("d", formatC(yday(dt), width = 3, flag = "0"), "_",
#          "h", formatC(hour(dt), width = 2, flag = "0"))
# }
# # check
# datetime2tsdh(today(tmz))
# 
# # Function to coerse time-slices names into data-time format, for a given year and time-zone.
# tsdh2datetime <- function(tslice, year = 2050, tz = tmz) {
#   DAY <- as.integer(substr(tslice, 2, 4)) - 1
#   HOUR <- as.integer(substr(tslice, 7, 8))
#   lubridate::ymd_h(paste0(year, "-01-01 0"), tz = tz) + days(DAY) + hours(HOUR)
# }
# # check
# tsdh2datetime("d365_h23")
# 
# # data.frame object with names of the final time-slices in the model
# #   and releted data-time information
slc_m12 <- tibble(
  slice = kronecker(timeslices_m12$MONTH, 
                    timeslices_m12$HOUR, FUN = "paste", sep = "_")
)
# # add date-time info
slc_m12$smonth <- substr(slc_m12$slice, 1, 3)
slc_m12$shour <- substr(slc_m12$slice, 5, 7)
slc_m12$month <- as.integer(substr(slc_m12$slice, 2, 3))
slc_m12$hour <- as.integer(substr(slc_m12$slice, 6, 7))
head(slc_m12)
tail(slc_m12)

```


# Commodities

```{r Commodities}
ELC <- newCommodity('ELC', slice = "HOUR")
CO2 <- newCommodity('CO2', slice = "HOUR")
SOL <- newCommodity('SOL', slice = "ANNUAL")
WIN <- newCommodity('WIN', slice = "ANNUAL")
WFF <- newCommodity('WFF', slice = "ANNUAL")

UHV <- newCommodity(
  name = 'UHV', 
  description = "Ultra High Voltage electricity",
  slice = "HOUR")

COA <- newCommodity(
  name = 'COA', 
  description = "All coals",
  emis = list( # 
    comm = "CO2", # 
    unit = "kt/GWh", # 
    mean = convert("kt/PJ", "kt/GWh", 100) # 
    ),
  slice = "ANNUAL")

GAS <- newCommodity(
  name = 'GAS', 
  description = "Natural gas",
  slice = "ANNUAL")

BIO <- newCommodity(
  name = 'BIO', 
  description = "Biomass",
  slice = "ANNUAL")

HYD <- newCommodity(
  name = 'HYD', 
  description = "Hydro energy",
  slice = "ANNUAL")

NUC <- newCommodity(
  name = 'NUC', 
  description = "Nuclear energy",
  slice = "ANNUAL")


```

# Demand   

## Full year, 8760 hours
Hourly demand by regions - no loadcurve data yet  

```{r ELC_demand_8760}
(load("data/dmd.RData"))
dmd <- dmd[dmd$region %in% reg_names,]
dmd$hour_GWh <- dmd$consum_GWh / 365 / 24 # evenly distributed

dmd_annual <- sum(dmd$consum_GWh)

loadcurve <- tibble(
  datetime = rep(ymd_h("2050-01-01 0", tz = tmz) + hours(0:(24*365 - 1)), nreg),
  region = rep(dmd$region, each = 24*365),
  GWh = rep(dmd$hour_GWh, each = 24*365)
)
loadcurve$slice <- datetime2tsdh(loadcurve$datetime)
head(loadcurve); tail(loadcurve)

# Demand class
DEM_ELC_DH <- newDemand(
  name = "DEM_ELC_DH",
  description = "Demand by regions, hours and year-days, full year",
  commodity = "ELC",
  unit = "GWh",
  dem = data.frame(
    year = myear, 
    region = loadcurve$region,
    slice = loadcurve$slice, 
    dem = round(loadcurve$GWh, 7)
    )
)

# Check
dim(DEM_ELC_DH@dem)
dim(DEM_ELC_DH@dem)[1] / 365 / 24
sum(DEM_ELC_DH@dem$dem); sum(dmd$consum_GWh)
summary(DEM_ELC_DH@dem$dem)
# Annual base-year demand
elc_dem_BY_GWh <- sum(DEM_ELC_DH@dem$dem)

```

## By days, 365 days
```{r}
loadcurve_YDAY <- loadcurve %>% 
  mutate(YDAY = substr(slice, 1, 4)) %>%
  group_by(region, YDAY) %>%
  summarise(GWh = sum(GWh))

DEM_ELCD <- newDemand(
  name = "DEM_ELCD",
  description = "Demand by regions, year-days",
  commodity = "ELCD",
  dem = data.frame(
    year = myear, 
    region = loadcurve_YDAY$region,
    slice = loadcurve_YDAY$YDAY, 
    dem = round(loadcurve_YDAY$GWh, 7)
    )
)

sum(DEM_ELCD@dem$dem)
DEM_ELCD@dem %>% as_tibble()

```

## By months and hours  
```{r}
loadcurve_m12h24 <- loadcurve %>% 
  mutate(MONTH = paste0("m",
           formatC(as.integer(month(datetime)), 
                   digits = 0, width = 2, flag = "0")),
         HOUR = substr(slice, 6, 8),
         slice = paste0(MONTH, "_", HOUR)
         ) %>%
  group_by(region, slice, MONTH, HOUR) %>%
  summarise(GWh = sum(GWh))

DEM_ELC_MH <- newDemand(
  name = "DEM_ELC",
  description = "Demand by regions, month-hours",
  commodity = "ELC",
  dem = data.frame(
    year = 2018, 
    region = loadcurve_m12h24$region,
    slice = loadcurve_m12h24$slice, 
    dem = round(loadcurve_m12h24$GWh, 7)
    )
)

sum(DEM_ELC_MH@dem$dem)
DEM_ELC_MH@dem %>% as_tibble()

```


## Alternative "flat" demand
(by now is equal to the *DEM_ELC_DH* since there is no load-curve data)
```{r}
# k <- 100
elc_dem_fx <- loadcurve # 
elc_dem_fx$year <- 2050L

for (y in unique(elc_dem_fx$year)) {
  for (r in reg_names) {
    ii <- elc_dem_fx$year == y & elc_dem_fx$region == r
    elc_dem_fx$GWh[ii] = mean(elc_dem_fx$GWh[ii]) # make it constant for each region and year
  }
}
elc_dem_fx$PJ <- convert("GWh", "PJ", elc_dem_fx$GWh)
elc_dem_fx

# Demand object
DEM_ELC_FX <- newDemand(
  name = "DEM_ELC_FX",
  description = "Flat, fixed demand for electricity",
  commodity = "ELC",
  dem = list(
    year = elc_dem_fx$year, 
    region = elc_dem_fx$region,
    slice = elc_dem_fx$slice, 
    dem = elc_dem_fx$GWh
    )
)
dim(DEM_ELC_FX@dem)
unique(DEM_ELC_FX@dem$year)
length(unique(DEM_ELC_FX@dem$region))
length(unique(DEM_ELC_FX@dem$slice))


DEM35 <- newCommodity("DEM35", slice = "HOUR")

ELC2DEM35 <- newTechnology(
  name = "ELC2DEM35",
  description = "Tech for allocatable variable demand 1x",
  # region = reg_names,
  input = list(
    comm = "ELC",
    unit = "GWh"
    # unit = "PJ"
  ),
  output = list(
    comm = "DEM35",
    unit = "GWh"
    # unit = "PJ"
  ),
  # cap2act = 31.536, #convert("GWh", "PJ", 24 * 365),
  cap2act = 24*365,
  afs = list(
    slice = "ANNUAL",
# The technology cannot produce less than 35% of annual capacity for each region
    afs.lo = .35
  )
)
draw(ELC2DEM35)

CELC2DEM35CAPFX <- newConstraintS(
  name = "CELC2DEM35CAPFX", 
  eq = "==",
  type = "capacity",
  for.each = list(
    year = 2050,
    tech = "ELC2DEM35"),
  for.sum = list(
    region = reg_names
  ),
  rhs = elc_dem_BY_GWh/365/24/ELC2DEM35@afs$afs.lo) # limit on capacity

```

## Optimized location of consumption
```{r}
DEM100 <- newCommodity("DEM100", slice = "HOUR")

ELC2DEM100 <- newTechnology(
  name = "ELC2DEM100",
  description = "Tech for allocatable static demand 1x",
  input = list(
    comm = "ELC",
    unit = "GWh"
    # unit = "PJ"
  ),
  output = list(
    comm = "DEM100",
    unit = "GWh"
    # unit = "PJ"
  ),
  # cap2act = 31.536, #convert("GWh", "PJ", 24 * 365),
  cap2act = 24*365,
  # afs = list(
  #   slice = "ANNUAL",
  #   afs.lo = 1
  # ),
  af = list(
    af.lo = 1
  ),
  # region = c("XJ", "XZ", "NM", "QH", "SC", "GS", "YN"), # Exporting regions only
  # invcost = list(
  #   invcost = 1e-3 # arbitrary small number for tracking
  # ), 
  olife = list(olife = 100)
)
draw(ELC2DEM100)

CELC2DEM100CAPFX <- newConstraintS(
  name = "CELC2DEM100CAPFX", 
  eq = "==",
  type = "capacity",
  for.each = list(
    year = 2050,
    tech = "ELC2DEM100"),
  for.sum = list(
    region = reg_names
  ),
  rhs = elc_dem_BY_GWh/365/24) # limit on capacity

CELC2DEM100CAPUP <- newConstraintS(
  name = "CELC2DEM100CAPUP", 
  eq = "<=",
  type = "capacity",
  for.each = list(
    year = 2050,
    region = reg_names,
    tech = "ELC2DEM100"),
  rhs = CELC2DEM100CAPFX@defVal/5) # at least 5 regions


```


# Renewables potential (weather factors)  
Assumptions:  
1sq.m PV requires ~2.5sq.m of land  
1.046 * 1.558 PV panel 345 Watt / 1.63 m2 ~= 200 Watt/m2 == .2 GW/km^2 /2.5 = .08 GW/km^2 = 80GW/1000km^2  

Wind onshore: Assuming 4 megawatts per square kilometer (about 10 megawatts per square mile, NREL)
Wind offshore: 3-5 megawatts (MW) per square kilometer
For simplicity, up to 3 GW per 1000 sq.km

```{r Weather}
# Solar AF
# dim(dhsol)
# head(dhsol)
(load("data/dhsol.RData"))

# ii <- rep(T, dim(dhsol)[1]) # filter if needed
ii <- dhsol$region %in% reg_names
summary(ii)

SOLAR_AF <- newWeather("SOLAR_AF",
                        description = "Ground level insolation AF",
                        # unit = "kWh/kWh_max",
                        slice = "HOUR",
                        weather = data.frame(
                          region = as.character(dhsol$region[ii]),
                          # year = 2017,
                          slice = dhsol$slice[ii],
                          wval = dhsol$WF[ii]
                        ))

head(SOLAR_AF@weather)
dim(SOLAR_AF@weather)[1] / nreg / 365 / 24 # Check: must be == 1

# Max capacity by MERRA-2 locations
# PV_GW_max_reg <- ysol %>%
#   group_by(region) %>%
#   summarise(GW_up = PV_GW_max * n())

reg_area$sol_max_GW <- 80 * reg_area$area_km2 / 1e3 # 80 GW / 1000 km if 100$ coverage
0.01 * sum(reg_area$sol_max_GW) # up to 1% of territory


# Wind AF (onshore)
(load("data/wnd_af10.RData"))
ii <- wnd_af10$region %in% reg_names
wnd_af10 <- wnd_af10[ii,]
wnd_af10$slice <- datetime2tsdh(wnd_af10$datetime)
wnd_af10
dim(wnd_af10)[1] / 365/24 # number of regions with the onshore potential
ii <- rep(T, dim(wnd_af10)[1]) # 
summary(wnd_af10$af50m)
# wnd_af20$region <- as.character(wnd_af20$region)
WIN10_AF <- newWeather("WIN10_AF",
                        description = "Onshore wind potential af20",
                        region = unique(wnd_af10$region[ii]),
                        # unit = "kWh/kWh_max",
                        slice = "HOUR",
                        weather = data.frame(
                          region = as.character(wnd_af10$region[ii]),
                          # year = 2010,
                          slice = wnd_af10$slice[ii],
                          wval = wnd_af10$af50m[ii]
                        ))
head(WIN10_AF@weather)
dim(WIN10_AF@weather)[1] / 365 / 24 # Check - number of regions with the data

win_max_GW <- group_by(wnd_af10, region) %>%
  summarise(max_GW = max(max_GWh))

# reg_area$win_max_GW <- 3 * reg_area$area_km2 / 1e3 # 3 GW / 1000 km if 100$ coverage
# 0.1 * sum(reg_area$win_max_GW) # up to 10% of territory


# Wind AF (offshore)
ii <- wndf_af10$region %in% reg_names
wndf_af10 <- wndf_af10[ii,]
wndf_af10$slice <- datetime2tsdh(wndf_af10$datetime)
wndf_af10
dim(wndf_af10)[1] / 365/24
ii <- rep(T, dim(wndf_af10)[1]) # 
summary(wndf_af10$af50m)
wndf_af10$region <- as.character(wndf_af10$region)
WIF10_AF <- newWeather("WIF10_AF",
                        description = "Offshore wind potential af20",
                        # unit = "kWh/kWh_max",
                        region = unique(wndf_af10$region),
                        slice = "HOUR",
                        weather = data.frame(
                          region = as.character(wndf_af10$region[ii]),
                          # year = 2010,
                          slice = wndf_af10$slice[ii],
                          wval = wndf_af10$af50m[ii]
                        ))
head(WIF10_AF@weather)
dim(WIF10_AF@weather)[1] / 365 / 24

wif_max_GW <- group_by(wndf_af10, region) %>%
  summarise(max_GW = max(max_GWh))


```

# Supply
Declaration of resources (upstream technologies) in the model.  
Here we use only solar and wind energy.  

```{r Solar_energy_potential}

RES_SOL <- newSupply(
  name = "RES_SOL",
  description = "Terrestrial solar radiation - maximum potential",
  commodity = "SOL",
  unit = "GWh",
# Weather factors could be used to regulate hourly supply of the resources.
# Though to reduce the model dimension, it is enough to use
# weather factors in technologies.
  # weather = data.frame(
  #   weather = c("SOLAR_AF"),
  #   wava.up =  c(1)
  #   ),
  # availability = list(
  #   # region = dh$region,
  #   # slice = dh$slice365,
  #   ava.up = 1e10 # Max available resource in hour, i.e. no limit by now
  # ),
  # slice = "HOUR"
  slice = "ANNUAL" # to reduce the model dimension
)

RES_WIN <- newSupply(
  name = "RES_WIN",
  description = "Onshore wind - maximum potential",
  commodity = "WIN",
  region = unique(wnd_af10$region),
  unit = "GWh",
  # weather = data.frame(
  #   weather = c("SOLAR_AF"),
  #   wava.up =  c(1)
  #   ),
#   availability = list(
#     region = wnd_af10$region,
#     slice = wnd_af10$slice,
# # here is an alternative (equivalent) way to use weather factors in supply
#     ava.up = wnd_af10$max_GWh # Max available resource in hour
#   ),
  slice = "ANNUAL"
)

RES_WFF <- newSupply(
  name = "RES_WFF",
  description = "Offshore wind - maximum potential",
  commodity = "WFF",
  region = unique(wndf_af10$region),
  unit = "GWh",
  # weather = data.frame(
  #   weather = c("SOLAR_AF"),
  #   wava.up =  c(1)
  #   ),
  # availability = list(
  #   region = wndf_af10$region,
  #   slice = wndf_af10$slice,
  #   ava.up = wndf_af10$max_GWh # Max available resource in hour
  # ),
  slice = "ANNUAL"
)

RES_HYD <- newSupply(
  name = "RES_HYD",
  description = "Simplified hydro-resource",
  commodity = "HYD",
  slice = "ANNUAL"
)

SUPNUC <- newSupply(
  name = "SUPNUC",
  commodity = "NUC",
  unit = "GWh",
  availability = list(
    # ava.up = convert("GWh", "PJ", 20*24*365),
    # http://www.world-nuclear.org/information-library/economic-aspects/economics-of-nuclear-power.aspx
    cost = convert("USD/kWh", "MUSD/GWh", .39/100)
  ),
  slice = "ANNUAL"
)

SUPCOA <- newSupply(
  name = "SUPCOA",
  commodity = "COA",
  description = "Simplified coal supply",
  availability = list(
    cost = convert("USD/tce", "MUSD/GWh", 70/.7)
  ),
  slice = "ANNUAL"
)

# 1,000 Cubic Feet Of Natural Gas to Therms (u.s.) = 10.0024
# 4 USD/cu.ft ~= 0.4 USD/therm
SUPGAS <- newSupply(
  name = "SUPGAS",
  description = "Simplified gas supply",
  commodity = "GAS",
  availability = list(
    cost = convert("USD/therm", "MUSD/GWh", 0.5)
  ),
  slice = "ANNUAL"
)

SUPOIL <- newSupply(
  name = "SUPOIL",
  description = "Simplified oil supply",
  commodity = "OIL",
  availability = list(
    cost = convert("USD/therm", "MUSD/GWh", 0.5)
  ),
  slice = "ANNUAL"
)

SUPBIO <- newSupply(
  name = "SUPBIO",
  description = "Simplified Biomass supply",
  commodity = "BIO",
  availability = list(
    cost = convert("USD/therm", "MUSD/GWh", 0.4) # assumption
  ),
  slice = "ANNUAL"
)


```

# Power generating technologies  

## Current stock
```{r}
(load("data/WRI/india_power_plants.RData"))

ggplot(data = gis_df) + 
  geom_polygon(aes(x = long, y = lat, group = group), fill = "wheat", 
               colour = "white", alpha = 1, size = .5) + # aes fill = id, 
  coord_fixed(1.) +
  # guides(fill=FALSE) + # do this to leave off the color legend
  theme_void() + 
  labs(title = "India's power plants (Global Power Plant Database, WRI, 2019)")  +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) +
  geom_point(data = pp, 
             aes(x = longitude, y = latitude, colour = primary_fuel, size = capacity_mw),
             alpha = .7) +
  guides(color = guide_legend(override.aes = list(size=5))) 

unique(pp$primary_fuel)
unique(pp$other_fuel1)
unique(pp$other_fuel2)
unique(pp$other_fuel3)
head(pp) %>% as.data.frame()

# Nation-wide capacity structure
pp %>% group_by(primary_fuel) %>%
  summarize(GW = sum(capacity_mw) / 1e3)

# aggregating by fuel types
ppa <- pp %>% 
  group_by(region, primary_fuel, other_fuel1, other_fuel2) %>%
  summarise(start_year = weighted.mean(commissioning_year, 
                                       w = capacity_mw,
                                       na.rm = T),
            cap_year = weighted.mean(year_of_capacity_data,
                                     w = capacity_mw,
                                     na.rm = T),
            cap_GW = sum(capacity_mw) / 1e3,
            gen_GWh = max(generation_gwh_2013,
                          generation_gwh_2014,
                          generation_gwh_2015,
                          generation_gwh_2016,
                          generation_gwh_2017, 
                          estimated_generation_gwh,
                          na.rm = T)) %>%
  mutate(af = gen_GWh / cap_GW / 365 / 24)
print(ppa, n = 1e3)

# There is one cogeneration (CHP) power plant, quite small
# We can aggregate it with all other plants or model separately
ii <- grepl("Cogen", ppa$other_fuel1, ); summary(ii)
ppa[ii,]

# CHP can be modeled this way:
ECHP <- newTechnology(
  name = "ECHP",
  description = "Cogeneration (CHP) coal-fired power plant",
  # region = ppa$region[ii],
  input = data.frame(
    comm = c("COA", "OIL"),
    unit = "GWh",
    group = "i"
  ),
  output = data.frame(
    comm = c("ELC", "HEAT"),
    unit = "GWh",
    group = "o"
  ), 
  geff = data.frame(
    group = "i",
    ginp2use = 1
  ),
  ceff = data.frame(
    comm = c("COA", "OIL", "ELC", "HEAT"),
    # cinp2use = c(.3, .4, NA, NA),
    use2cact = c(NA, NA, 0.3, 0.3),
    cact2cout = c(NA, NA, 1, 3),
    share.up = c(NA, NA, .5, NA),
    share.fx = c(NA, 0.03, NA, NA)
  )
)
draw(ECHP)

# ..., but for now, since the capacity of the plant is too small,
# and we don't model demand for heat,
# and we don't have all CHP parameters
# let's just aggregate it with other coal plants.
# Also, many coal plants are using Oil as a start-up fuel,
# for simplicity we can drop the second fuel and use only first one.
# And for simplicity, we can aggregate Gas and Oil power plants
# Therefore, we need to reaggregate:

ppb <- pp %>%
  mutate(primary_fuel = plyr::revalue(primary_fuel, c("Oil" = "Gas"))) %>%
  group_by(region, primary_fuel) %>%
  summarise(start_year = weighted.mean(commissioning_year, 
                                       w = capacity_mw,
                                       na.rm = T),
            cap_year = weighted.mean(year_of_capacity_data,
                                     w = capacity_mw,
                                     na.rm = T),
            cap_GW = sum(capacity_mw) / 1e3,
            gen_GWh = max(generation_gwh_2013,
                          generation_gwh_2014,
                          generation_gwh_2015,
                          generation_gwh_2016,
                          generation_gwh_2017, 
                          estimated_generation_gwh,
                          na.rm = T)) %>%
  mutate(af = gen_GWh / cap_GW / 365 / 24)
print(ppb, n = 1e3)

# EHYD -- Hydro plants####
{ii <- grepl("hydro", ppb$primary_fuel, ignore.case = T); summary(ii)
ppb[ii,]

EHYD_BY <- newTechnology( 
  name = "EHYD_BY",
  description = "Hydro power plants, base year",
  region = ppb$region[ii],
  input = list(
    comm = "HYD",
    unit = "GWh",
    combustion = 0
  ),
  output = list(
    comm = "ELC",
    unit = "GWh"
  ),
  cap2act = 24*365,
  ceff = list(
    comm = c("HYD"),
    cinp2use = c(1)
  ),
  af = list(
    region = ppb$region[ii],
    # slice = ,
    af.fx = ppb$af[ii]
  ),
  # fixom = list(
  #   fixom = 
  # ),
  # varom = list(
  #   varom = 
  # ),
  # invcost = list(
  #   # year = 2010,
  #   invcost = 
  # ),
  stock = data.frame(
    region = c(ppb$region[ii], ppb$region[ii]),
    year = c(rep(2018, sum(ii)), rep(2060, sum(ii))),
    stock = c(ppb$cap_GW[ii], ppb$cap_GW[ii])
  ),
  # start = list(
  #   start = 2060
  # ),
  end = list(
    end = 2010
  ),
  # olife = list(
  #   olife = 80
  # ),
  slice = 'HOUR'
)

draw(EHYD_BY)
}

# ENUC -- Nuclear plants####
{ii <- grepl("nuclear", ppb$primary_fuel, ignore.case = T); summary(ii)
ppb[ii,]

ENUC_BY <- newTechnology( 
  name = "ENUC_BY",
  description = "Nuclear power plants, base year",
  region = ppb$region[ii],
  input = list(
    comm = "NUC",
    unit = "GWh",
    combustion = 0
  ),
  output = list(
    comm = "ELC",
    unit = "GWh"
  ),
  cap2act = 24*365,
  ceff = list(
    comm = c("NUC"),
    cinp2use = c(1)
  ),
  af = data.frame(
    region = ppb$region[ii],
    # slice = ,
    af.fx = 0.9 #ppb$af[ii]
  ),
  # fixom = list(
  #   fixom = 
  # ),
  varom = list(
    varom = 0.7 # assumed costs of production
  ),
  # invcost = list(
  #   # year = 2010,
  #   invcost = 
  # ),
  stock = data.frame(
    region = c(ppb$region[ii], ppb$region[ii]),
    year = c(rep(2018, sum(ii)), rep(2060, sum(ii))),
    stock = c(ppb$cap_GW[ii], ppb$cap_GW[ii])
  ),
  # start = list(
  #   start = 2060
  # ),
  end = list(
    end = 2010
  ),
  # olife = list(
  #   olife = 80
  # ),
  slice = 'HOUR'
)

draw(ENUC_BY)
}

# EBIO - Biomass power plants ####
{
ii <- grepl("bio", ppb$primary_fuel, ignore.case = T); summary(ii)
ppb[ii,] # !!! errors in data (check af)

EBIO_BY <- newTechnology( 
  name = "EBIO_BY",
  description = "Generic Biomass-fired power plant, base year",
  region = ppb$region[ii],
  input = list(
    comm = "BIO",
    unit = "GWh",
    combustion = 1
  ),
  output = list(
    comm = "ELC",
    unit = "GWh"
  ),
  cap2act = 24*365,
  ceff = list(
    comm = c("BIO"),
    cinp2use = c(.35)
  ),
  afs = list(
    slice = "ANNUAL",
    afs.up = .6 # assumption
  ),
  # fixom = list(
  #   fixom = 
  # ),
  # varom = list(
  #   varom = 0.01 # USD/kWh - assumption
  # ),
  invcost = list(
    invcost = 3000
  ),
  stock = data.frame(
    region = c(ppb$region[ii], ppb$region[ii]),
    year = c(rep(2018, sum(ii)), rep(2040, sum(ii))),
    stock = c(ppb$cap_GW[ii], .8*ppb$cap_GW[ii]) # assumption
  ),
  end = list(
    end = 2010
  ),
  # olife = list(
  #   olife = 30
  # ),
  slice = 'HOUR'
)
draw(EBIO_BY)  
  
}


# ECOA - Coal power plants ####
{
ii <- grepl("coal", ppb$primary_fuel, ignore.case = T); summary(ii)
ppb[ii,] # !!! errors in data (check af)

ECOA_BY <- newTechnology( 
  name = "ECOA_BY",
  description = "Generic Coal-fired power plant, base year",
  region = ppb$region[ii],
  input = list(
    comm = "COA",
    unit = "GWh",
    combustion = 1
  ),
  output = list(
    comm = "ELC",
    unit = "GWh"
  ),
  cap2act = 24*365,
  ceff = list(
    comm = c("COA"),
    cinp2use = c(.35)
  ),
  afs = list(
    slice = "ANNUAL",
    afs.up = .6 # assumption
  ),
  # fixom = list(
  #   fixom = 
  # ),
  # varom = list(
  #   varom = 0.01 # USD/kWh - assumption
  #   # convert("USD/kWh", "MUSD/GWh", 1)
  # ),
  # invcost = list(
  #   invcost = 
  # ),
  stock = data.frame(
    region = c(ppb$region[ii], ppb$region[ii]),
    year = c(rep(2018, sum(ii)), rep(2040, sum(ii))),
    stock = c(ppb$cap_GW[ii], .7*ppb$cap_GW[ii]) # assumption
  ),
  end = list(
    end = 2010
  ),
  # olife = list(
  #   olife = 30
  # ),
  slice = 'HOUR'
)
draw(ECOA_BY)  
  
}

# EGAS - GAS & oil power plants ####
{
# aggregating Gas & Oil power plants
ii <- grepl("gas", ppb$primary_fuel, ignore.case = T); summary(ii)
ppb[ii,] # !!! errors in data (check af)
EGAS_BY <- newTechnology( 
  name = "EGAS_BY",
  description = "Generic Gas-fired power plant, base year",
  region = ppb$region[ii],
  input = list(
    comm = "GAS",
    unit = "GWh",
    combustion = 1
  ),
  output = list(
    comm = "ELC",
    unit = "GWh"
  ),
  cap2act = 24*365,
  ceff = list(
    comm = c("GAS"),
    cinp2use = c(.45)
  ),
  afs = list(
    slice = "ANNUAL",
    afs.up = .4 # assumption
  ),
  # fixom = list(
  #   fixom = 
  # ),
  # varom = list(
  #   varom = 0.01 # USD/kWh - assumption
  #   # convert("USD/kWh", "MUSD/GWh", 1)
  # ),
  # invcost = list(
  #   invcost = 
  # ),
  stock = data.frame(
    region = c(ppb$region[ii], ppb$region[ii]),
    year = c(rep(2018, sum(ii)), rep(2040, sum(ii))),
    stock = c(ppb$cap_GW[ii], .7*ppb$cap_GW[ii]) # assumption
  ),
  end = list(
    end = 2010
  ),
  # olife = list(
  #   olife = 30
  # ),
  slice = 'HOUR'
)
draw(EGAS_BY)  

}


```


## New technologies

```{r Technologies}

ESOL <- newTechnology(
  name = "ESOL",
  description = "Utility Scale Solar PV",
  # region = "AZ",
  input = list(
    comm = "SOL",
    unit = "GWh"
  ),
  output = list(
    comm = "ELC",
    unit = "GWh"
  ),
  cap2act = 365*24,
  af = list(
    af.fx = 1 # forcing output when resource is available
  ),
  weather = list(
    weather = c("SOLAR_AF"),
    waf.fx = 1 # weather factor (multiplier) will be applied to af.fx
  ),
  # fixom = list(
  #   fixom = 10 # assumed, 1% of investment costs a year
  # ),
  invcost = list(
    # Assuming 1$/Watt 
    # https://www.nrel.gov/news/press/2017/nrel-report-utility-scale-solar-pv-system-cost-fell-last-year.html
    invcost = 1000 # convert("USD/W", "MUSD/GW", 1)
  ),
  # start = list(
  #   start = 2017
  # ),
  olife = list(
    olife = 25
  )
)
draw(ESOL)

CSOL_UP <- newConstraintS(
  name = "CSOL_UP",
  eq = "<=",
  type = "capacity",
  for.each = data.frame(
    year = 2050L,
    tech = "ESOL",
    region = reg_area$region),
  rhs = data.frame(
    year = 2050L,
    tech = "ESOL",
    region = reg_area$region,
    rhs = 0.02 * round(reg_area$sol_max_GW, 0) # up to 2% of therritory per region
  )
)


EWIN <- newTechnology(
  name = "EWIN",
  description = "Onshore wind farm",
   WIN10_AF@region, # Limiting to regions with available resource
  input = list(
    comm = "WIN",
    unit = "GWh"
  ),
  output = list(
    comm = "ELC",
    unit = "GWh"
  ),
  cap2act = 365*24,
  af = list(
    af.fx = 1 # forcing output when resource is available
  ),
  weather = list(
    weather = c("WIN10_AF"),
    waf.fx = c(1)
    # waf.up = c(1) # 
  ),
  # fixom = list(
  #   fixom = 15 # Assumed, 1% a year
  # ),
  invcost = list(
    # Assuming 1.5$/Watt 
    # https://www.irena.org/-/media/Files/IRENA/Agency/Publication/2018/Jan/IRENA_2017_Power_Costs_2018.pdf
    invcost = 1500 # 
  ),
  # start = list(
  #   start = 2017
  # ),
  olife = list(
    olife = 25
  )
)
draw(EWIN)

CWIN_UP <- newConstraintS(
  name = "CWIN_UP",
  eq = "<=",
  type = "capacity",
  for.each = data.frame(
    year = 2050L,
    tech = "EWIN",
    region = win_max_GW$region),
  rhs = data.frame(
    year = 2050L,
    tech = "EWIN",
    region = win_max_GW$region,
    rhs = 0.1 * round(win_max_GW$max_GW, 0) # up to 10% of territory per region
  )
)

EWFF <- newTechnology(
  name = "EWFF",
  description = "Offshore wind farm",
  region = WIF10_AF@region, # Limiting to regions with available resource
  input = list(
    comm = "WFF",
    unit = "GWh"
  ),
  output = list(
    comm = "ELC",
    unit = "GWh"
  ),
  cap2act = 365*24,
  af = list(
    af.fx = 1 # forcing output when resource is available
  ),
  weather = list(
    weather = c("WIF10_AF"),
    waf.up = c(1) # 
  ),
  # fixom = list(
  #   fixom = 45 # Assumed, 1% a year
  # ),
  invcost = list(
    # Assuming 3-4.5$/Watt 
    # https://www.irena.org/-/media/Files/IRENA/Agency/Publication/2018/Jan/IRENA_2017_Power_Costs_2018.pdf
    # https://www.energy.gov/sites/prod/files/2019/08/f65/2018%20Offshore%20Wind%20Market%20Report.pdf
    invcost = 3500 # convert("USD/W", "MUSD/GW", 1)
  ),
  # start = list(
  #   start = 2017
  # ),
  olife = list(
    olife = 25
  )
)
draw(EWFF)

CWIF_UP <- newConstraintS(
  name = "CWIF_UP",
  eq = "<=",
  type = "capacity",
  for.each = data.frame(
    year = 2050L,
    tech = "EWIF",
    region = wif_max_GW$region),
  rhs = data.frame(
    year = 2050L,
    tech = "EWIF",
    region = wif_max_GW$region,
    rhs = 0.1 * round(wif_max_GW$max_GW, 0) # up to 10% of territory per region
  )
)

```


# Storage technologies

```{r Storage}
# STGBTR Hourly - within 24h ####
STGBTR <- newStorage(
  name = 'STGBTR',
  commodity = 'ELC',
  description = "Generic grid-integrated intraday storage (battery)",
  cap2stg = 1, # 
  olife = list(olife = 20), 
  invcost = list(
    # See IRENA 2030 (from 77 to 574, p.77)
    invcost = convert("USD/kWh", "MUSD/GWh", 200)
    ), 
  seff = data.frame(
    inpeff = 0.8, # assumed efficiency of charging 
    stgeff = 0.9 # assumed efficiency of storing energy (annual)
    # outeff = 1 # discharge efficiency
    )
)

STGBTR1 <- newStorage(
  name = 'STGBTR',
  commodity = 'ELC',
  description = "Generic grid-integrated intraday storage (battery)",
  cap2stg = 1, # 
  olife = list(olife = 20), 
  invcost = list(
    # See IRENA 2030 (from 77 to 574, p.77)
    invcost = convert("USD/kWh", "MUSD/GWh", 200)
    ), 
  seff = data.frame(
    inpeff = 0.8, # assumed efficiency of charging 
    stgeff = 0.9, # assumed efficiency of storing energy (annual)
    cinp.up = 24*365 * 2, # 1/2-hour charging
    cout.up = 24*365 / 2 # 2-hour storage (discharging, i.e. GW capacity)
    # outeff = 1 # discharge efficiency
    )
)

# STGP2P Daily - within 365 days ####
# STGP2P1 <- newStorage(
#   name = 'STGP2P',
#   commodity = 'ELCD',
#   description = "Power-to-power type of technology",
#   cap2stg = 1, # if in PJ, convert("GWh", "PJ"),
#   olife = list(
#     olife = 25), 
#   invcost = 50, # USD/kWh, assumption
#   seff = data.frame(
#     inpeff = 0.8, # power to H2 efficiency
#     cinp.up = 24*365 / 100, # speed of P2X conversion for 1GW of storage
#     cout.up = 24*365 / 100,  # speed of X2P conversion for 1GW of storage
#     outeff = 0.6 # H2 to power efficiency
#     # stgeff = .9 
#     ),  
#   varom = list(
#     # Assuming high operational costs, adding ~ 5 cents/kWh
#     inpcost = convert("USD/kWh", "MUSD/GWh", .05)
#     )
# )

```


# Interregional UHV electrical grid
```{r Trade_bidirect_UHV_INV, eval=TRUE}
# Propose trade matrix between regions
{
if (F) { 
  # Load trade matrix from your file
  trd_xl <- readxl::read_excel("data/trade_matrix01.xlsx",
                               range = "A1:AX50")

  trd_nbr <- as.matrix(trd_xl[,-1])
  trd_nbr[lower.tri(trd_nbr)] <- NA
  rownames(trd_nbr) <- trd_xl$region
} else { 
  # Or create trade matrix for all neighbour regions
  trd_nbr <- matrix(rep(NA, nreg_in_gis*nreg_in_gis),
                    nrow = nreg_in_gis,
                    dimnames = list(reg_names_in_gis, reg_names_in_gis))
  # trd_nbr <- matrix(rep(NA, nreg*nreg),
  #                   nrow = nreg,
  #                   dimnames = list(reg_names, reg_names))
  head(trd_nbr)
  dim(trd_nbr)
  
  for (i in 1:length(reg_names_in_gis)) {
    trd_nbr[i, nbr[[i]]] <- 1
    trd_nbr[nbr[[i]], i] <- 1
  }
  dim(trd_nbr)
  summary(!is.na(c(trd_nbr)))
  ii <- reg_names_in_gis %in% reg_names
  # ii <- reg_names %in% reg_names
  trd_nbr <- trd_nbr[ii, ii]
  dim(trd_nbr)
  # For bidirectional trade, keep only one direction
  trd_nbr[lower.tri(trd_nbr)] <- NA
  summary(!is.na(c(trd_nbr)))
}
head(trd_nbr)
# write.csv(trd_nbr, file = "data/trade_matrix.csv")
trd_nbr[trd_nbr == 0] <- NA

# Convert the matrix to data.frame (table) format
trd_dt <- as.data.frame.table(trd_nbr, stringsAsFactors = F)
trd_dt <- trd_dt[!is.na(trd_dt$Freq),]
head(trd_dt)
dim(trd_dt)
trd_dt <- dplyr::distinct(trd_dt)
dim(trd_dt)
names(trd_dt) <- c("src", "dst", "trade")
trd_dt$trade <- with(trd_dt, paste0("TRBD_UHV_", src, "_", dst))
head(trd_dt)

# Map region flows
trd_map <- left_join(trd_dt, reg_centers[,1:3], by = c("src" = "region")) %>%
  left_join(reg_centers[,1:3], by = c("dst" = "region")) %>%
  rename(xsrc = x.x, ysrc = y.x,
         xdst = x.y, ydst = y.y) %>%
  as_tibble()

# a <- value
trd_flows_map <-
ggplot(data = gis_df) + 
    geom_polygon(aes(x = long, y = lat, group = group), fill = "wheat", 
                 colour = "white", alpha = 1, size = .5) + # aes fill = id, 
    coord_fixed(1) +
    guides(fill=FALSE) +  # do this to leave off the color legend
    theme_void() + labs(title = "Available for investment interregional long distance power lines")  + 
    theme(plot.title = element_text(hjust = 0.5), 
          plot.subtitle = element_text(hjust = 0.5)) +
    geom_segment(aes(x=xsrc, y=ysrc, xend=xdst, yend=ydst), 
                 data = trd_map, inherit.aes = FALSE, size = 4, 
                 alpha = 1, colour = "grey", lineend = "round", show.legend = T) +
    geom_point(data = reg_centers, aes(x, y), colour = "red") +
    geom_segment(aes(x=xsrc, y=ysrc, xend=xdst, yend=ydst), 
                 data = trd_map, inherit.aes = FALSE, size = .1, 
             # arrow = arrow(type = "closed", angle = 15, 
             #               length = unit(0.15, "inches")),
             colour = "darkgrey", alpha = 1, 
             lineend = "butt", linejoin = "mitre", show.legend = T) # , name = "Trade, PJ"
trd_flows_map
# ggsave("fig/trd_flows_map.pdf", trd_flows_map, device = "pdf")
}
# Calculate distance between regions centers:
# labpt <- get_labpt_spdf(gis_sp)
labpt <- reg_centers
# rownames(labpt) <- labpt[,"region"]

# Estimate grid length, losses, costs
trd_dt$distance_km <- 0.
for (i in 1:dim(trd_dt)[1]) {
  rg_dst <- trd_dt$dst[i]
  rg_src <- trd_dt$src[i]
  ii <- labpt$region == rg_dst
  lab_dst <- c(labpt$x[ii], labpt$y[ii])
  ii <- labpt$region == rg_src
  lab_src <- c(labpt$x[ii], labpt$y[ii])
  trd_dt$distance_km[i] <- raster::pointDistance(
    lab_src, lab_dst, T)/1e3
}

# Assume 15% longer distance due to a landscape
trd_dt$distance_km <- 1.15 * trd_dt$distance_km
# Assume losses 2% per 1000 km
# trd_dt$losses <- round(trd_dt$distance_km / 1e3 * 0.02, 4)
# Assume losses 1% per 1000 km (UHVDC)
trd_dt$losses <- round(trd_dt$distance_km / 1e3 * 0.01, 4)
trd_dt$teff <- 1 - trd_dt$losses
# Assumption based on ABB's 4000-8000 MUSD per 12GW UHVDC, 2000km, 1-5% system losses
# i.e. ~$160-333 MUSD/1000km per 1GW of the total system 
# assuming ~$200 MUSD/1000km per 1GW of power line,
# and $50 MUSD/GW for converter stations on each end
trd_dt$invcost <- round(trd_dt$distance_km / 1e3 * 200) # MUSD/GW of 1000km UHVDC
trd_dt <- as_tibble(trd_dt)

# Define trade object for every route, 
# store in a repository object
TRBD_UHV_NEI <- newRepository(name = "TRBD_UHV_NEI")
for (i in 1:dim(trd_dt)[1]) {
  src <- trd_dt$src[i]
  dst <- trd_dt$dst[i]
  trd_nm <- paste0("TRBD_UHV_", src, "_", dst)  # Trade object name
  cmd_nm <- "UHV"
  # Trade class for every route
  trd <- newTrade(trd_nm,
                  commodity = cmd_nm,
                  # source = c(src, dst),
                  # destination = c(src, dst),
                  routes = list(
                    src = c(src, dst),
                    dst = c(dst, src)
                  ),
                  trade = data.frame(
                    src = c(src, dst),
                    dst = c(dst, src),
                    # Maximum capacity per route in GW
                    # ava.up = convert("GWh", "GWh", 60), (!!! bug)
                    teff = trd_dt$teff[i] # trade losses
                    # cost = trd_dt$cost[i]  # trade costs
                    # markup = trd_dt$cost[i] # and/or markup
                    ),
                  #!!! New stuff - testing
                  capacityVariable = TRUE, # The trade route has capacity (not just flow) and can be endogenous
                  # bidirectional = TRUE, #
                  invcost = data.frame(
                    # src = src,
                    # dst = dst,
                    # year = 2010,
                    region = c(dst, src),
                    invcost = trd_dt$distance_km[i] / 1e3 * 250 / 2 # 
                  ),
                  # olife = data.frame(
                  olife = 80,
                  # ),
                  cap2act = convert("GWh", "GWh", 24*365)
                  )
  
  TRBD_UHV_NEI <- add(TRBD_UHV_NEI, trd)
}
names(TRBD_UHV_NEI@data)
TRBD_UHV_NEI@data[[1]]

```


# Fixing grid capacity
Endogenous grid is computantionally intensive, fixing it will speed-up the solution for quick scenarios.
```{r}
TRBD_UHV_NEI_FX <- TRBD_UHV_NEI # Grid with flow limits, not capacity variable
TRBD_UHV_NEI_FX_CAP <- TRBD_UHV_NEI # Grid with fixed capacity

trd <- newTrade("",
                stock = list(year = 2050, stock = 100), # GW - almost unlimiting
                end = 2010
                )

trd_empty <- newTrade("")

for (i in 1:length(TRBD_UHV_NEI_FX@data)) {
  TRBD_UHV_NEI_FX_CAP@data[[i]]@stock <- trd@stock
  TRBD_UHV_NEI_FX_CAP@data[[i]]@end <- trd@end
  
  TRBD_UHV_NEI_FX@data[[i]]@trade$ava.up <- 100
  TRBD_UHV_NEI_FX@data[[i]]@capacityVariable <- F
  TRBD_UHV_NEI_FX@data[[i]]@invcost <- trd_empty@invcost
  TRBD_UHV_NEI_FX@data[[i]]@olife <- trd_empty@olife
}
# TRBD_UHV_NEI_FX@data$TRBD_UHV_AR_AS
# TRBD_UHV_NEI_FX_CAP@data$TRBD_UHV_AR_AS

# Dropping UHV and converter stations, i.e. trade with ELC
TRBD_ELC_NEI_FX_CAP <- TRBD_UHV_NEI_FX_CAP # Grid with fixed capacity
TRBD_ELC_NEI_FX <- TRBD_UHV_NEI_FX
for (i in 1:length(TRBD_ELC_NEI_FX_CAP@data)) {
  TRBD_ELC_NEI_FX_CAP@data[[i]]@name <- sub("_UHV_", "_ELC_", TRBD_ELC_NEI_FX_CAP@data[[i]]@name)
  TRBD_ELC_NEI_FX_CAP@data[[i]]@commodity <- "ELC"
  
  TRBD_ELC_NEI_FX@data[[i]]@name <- sub("_UHV_", "_ELC_", TRBD_ELC_NEI_FX@data[[i]]@name)
  TRBD_ELC_NEI_FX@data[[i]]@commodity <- "ELC"
}

rm(trd, trd_empty)

```

# Inverter and rectifier stations
```{r UHV_rectifiers_inverters}
# Parameters assumed or calibrated based on 
# ABB's 4000-8000 MUSD per 12GW, 2000km, 1-5%
# and other sources

ELC2UHV <- newTechnology(
  name = "ELC2UHV",
  description = "Converter stations - ELC to UHV",
  input = list(
    comm = "ELC",
    unit = "GWh"
    # unit = "PJ"
  ),
  output = list(
    comm = "UHV",
    unit = "GWh"
    # unit = "PJ"
  ),
  # cap2act = 31.536,
  cap2act = 24*365,
  ceff = list(
    comm = "ELC",
    cinp2use = .99 # see also Siemens -- 3% total losses for HVDC/1000km
  ),
  slice = "HOUR",
  invcost = list(
    invcost = 50  # 
  ),
  olife = 20 # assumed
)  
draw(ELC2UHV)


UHV2ELC <- newTechnology(
  name = "UHV2ELC",
  description = "Converter stations - UHV to ELC",
  input = list(
    comm = "UHV",
    unit = "GWh"
    # unit = "PJ"
  ),
  output = list(
    comm = "ELC",
    unit = "GWh"
    # unit = "PJ"
  ),
  # cap2act = 31.536,
  cap2act = 24*365,
  ceff = list(
    comm = "UHV",
    cinp2use = .99
  ),
  slice = "HOUR",
  invcost = list(
    invcost = 50 # Assumed, based on ABB data
  ),
  olife = 20 # assumed
)  
draw(UHV2ELC)

```

# Curtailments
Modeled as a trade with the rest of the world (ROW), export and import with fixed price.  
```{r ROW_trade}

# Adding the export is optional, `vBalance` captures unused electricity
EEXP <- newExport(
  name = "EEXP",
  description = "Supply curtalments (artificial export to capture excessive ELC production by renewables)",
  commodity = "ELC",
  exp = list(
    price = convert("USD/kWh", "MUSD/GWh", .01/1000) # 1/1000 cents per kWh
  )
)

EIMP1 <- newImport(
  name = "EIMP",
  description = "Demand curtailments, electricity import at high price (to identify needs for back-up techs such as biomass)",
  commodity = "ELC",
  imp = list(
    price = convert("USD/kWh", "MUSD/GWh", 1) # USD per kWh, marginal price
  )
)

EIMP5 <- EIMP1
EIMP5@imp$price <- 5

EIMP10 <- EIMP1
EIMP10@imp$price <- 10

```


# The Model 
## Balancing version, 8760 hours, 1 year
The base model and scenario:  
- generic electricity (ELC);  
- three types of renewables; 
- two types of energy storage;  
- no inter-regional trade/dispatch.  

```{r Model_RENBAL, eval=TRUE}
# Repository with all the data-objects
reps <- add(newRepository('main_repository'), 
  # Commodities
  ELC, SOL, WIN, WFF, #UHV,
  # Resources (supply)
  RES_SOL, RES_WIN, RES_WFF,
  # Weather factors
  SOLAR_AF, WIF10_AF, WIN10_AF,
  # Generating technologies
  ESOL, EWIN, EWFF,
  CSOL_UP, CWIN_UP, CWIF_UP,
  # Storage
  # STGBTR, 
  #STGP2P1,
  # Simplified interregional ELC trade
  # TRD_ELC_ALL,
  # UHV grid
  # TRBD_UHV_NEI,
  # ELC2UHV, UHV2ELC,
  # Export/Import,
  # EEXP, 
  EIMP1 # low reliability (low marginal cost, high demand curtailments)
  # ELC demand with load curve (24 hours x 365 days)
  # DEM_ELC_DH # static
)
length(reps@data)
names(reps@data)

# model-class object 
mdl <- newModel(
  name = 'RENBAL', 
  description = "Renewables balancing model",
  ## in case of infeasibility, `dummy` variables can be added
  # debug = data.frame(#comm = "ELC",
  #                    dummyImport = 1e6,
  #                    dummyExport = 1e6),
  region = reg_names,
  discount = 0.05,
  slice = list(ANNUAL = "ANNUAL",
               # MONTH = timeslices$MONTH, 
               # HOUR = timeslices$HOUR
               YDAY = timeslices365$YDAY, 
               HOUR = timeslices365$HOUR
               ),
  repository = reps,
  # GIS = gis_sp,
  early.retirement = F)

# Check the model time-slices
head(mdl@sysInfo@slice@levels)

# Set milestone-years
# mdl <- setMilestoneYears(mdl, start = 2015, interval = c(1, 2, 5, 6, 7, rep(10, 3)))
mdl <- setMilestoneYears(mdl, start = 2050, interval = c(1))
mdl@sysInfo@milestone # check

# (optional) the model info
{mdl@description <- "
India power sector, renewables balancing version,
30 regions, 1 hour resolution,
3 types of renewables, 
1 types of storages,
no initial stock."}

# mdl2 <- mdl
# mdl2@data$main_repository@data$EIMP <- EIMPLO

```

## Transitional model, 12 months, 24 hours, 2018-2050  
(testing Base-Year only)
```{r Model_BASEYEAR, eval=FALSE}
# Repository with all the data-objects
repo_BY <- add(newRepository('base_year_repository'), 
  # Commodities
  ELC, SOL, WIN, WFF, #UHV,
  COA, GAS, BIO, HYD, NUC, CO2,
  # Resources (supply)
  RES_SOL, RES_WIN, RES_WFF, RES_HYD,
  SUPCOA, SUPGAS, SUPBIO, SUPNUC,
  # Weather factors
  # SOLAR_AF, WIF10_AF, WIN10_AF,
  # BY generating technologies
  ECOA_BY, EGAS_BY, EBIO_BY, EHYD_BY, ENUC_BY,
  # New technologies
  # ESOL, EWIN, EWFF,
  # CSOL_UP, CWIN_UP, CWIF_UP,
  # Storage
  # STGBTR, 
  #STGP2P1,
  # Simplified interregional ELC trade
  # TRD_ELC_ALL,
  # UHV grid
  # TRBD_UHV_NEI,
  # ELC2UHV, UHV2ELC,
  # Export/Import,
  # EEXP, 
  EIMP1 # reliability level
  # ELC demand with load curve (24 hours x 365 days)
  # DEM_ELC_DH # static
)
length(repo_BY@data)
names(repo_BY@data)

# model-class object 
mdl_BY <- newModel(
  name = 'INDEM_BY', 
  description = "Transitional model",
  ## in case of infeasibility, `dummy` variables can be added
  # debug = data.frame(#comm = "ELC",
  #                    dummyImport = 1e6,
  #                    dummyExport = 1e6),
  region = reg_names,
  discount = 0.05,
  slice = list(ANNUAL = "ANNUAL",
               # MONTH = timeslices$MONTH, 
               # HOUR = timeslices$HOUR
               MONTH = timeslices_m12$MONTH, 
               HOUR = timeslices_m12$HOUR
               ),
  repository = repo_BY,
  # GIS = gis_sp,
  early.retirement = F)

# Check the model time-slices
head(mdl_BY@sysInfo@slice@levels)
sum(mdl_BY@sysInfo@slice@levels$share)

# Set milestone-years
# mdl <- setMilestoneYears(mdl, start = 2015, interval = c(1, 2, 5, 6, 7, rep(10, 3)))
mdl_BY <- setMilestoneYears(mdl_BY, start = 2018, interval = c(1, 3, 4, 5))
mdl_BY@sysInfo@milestone # check

# (optional) the model info
{mdl_BY@description <- "
India power sector, renewables balancing version,
30 regions, 12 months x 24 hours,
Base year technologies,
3 types of renewables, 
1 types of storages,
no initial stock."}

# test scenario
scen_INDEMBY <- interpolate(add(mdl_BY, STGBTR, DEM_ELC_MH), name = "INDEM_BY", 
  description = "No inter-regional dispatch.")
summary(scen_INDEMBY)

# 2. Writing the model code and data in folder
write_model(scen_INDEMBY, tmp.dir = "solwork/scen_INDEMBY", solver = GAMS)
# save(scen_RENBAL1, file = "tmp/scen_RENBAL1.RData")

# 3. Solving the model
solve_model(tmp.dir = "solwork/scen_INDEMBY", wait = F)

# 4. Read the solution (# after GAMS has finished)
if (F) { 
  scen_INDEMBY <- read_solution(scen_INDEMBY, dir.result = "solwork/scen_INDEMBY")
  summary(scen_INDEMBY)

}
```

# Scenario 1: No interregional trade  
~ 4 mins to solve
```{r scen_RENBAL1, eval=F}
# Workflow to solve the model (recommended for large models):
# 1. Interpolation of parameters
scen_RENBAL1 <- interpolate(add(mdl, STGBTR, DEM_ELC_DH), name = "RENBAL1", 
  description = "No inter-regional dispatch.")
summary(scen_RENBAL1)

# 2. Writing the model code and data in folder
write_model(scen_RENBAL1, tmp.dir = "solwork/scen_RENBAL1", solver = GAMS)
# save(scen_RENBAL1, file = "tmp/scen_RENBAL1.RData")

# 3. Solving the model
solve_model(tmp.dir = "solwork/scen_RENBAL1", wait = F)

# 4. Read the solution (# after GAMS has finished)
if (F) { 
  if (!exists("scen_RENBAL1")) load("tmp/scen_RENBAL1.RData")
  summary(scen_RENBAL1)
  scen_RENBAL1 <- read_solution(scen_RENBAL1, dir.result = "solwork/scen_RENBAL1")
  summary(scen_RENBAL1)
  
  save(scen_RENBAL1, file = "scenarios/scen_RENBAL1.RData")
  # load("scenarios/scen_RENBAL1.RData")
}

```

## Solving with Python/Pyomo  
Solving the same scenario using Python/Pyomo with CBC or CPLEX, for comparison.
~ 15 min to generate 5-region model in Pyomo, <1 min to solve with CPLEX or CBC
```{r scen_RENBAL1_py, eval=F}
Pyomo <- list(
  lang = "PYOMO",
  export_format = "SQLite",
  solver = "cplex"
  # solver = "cbc"
)
# Workflow to solve the model (recommended for large models):
# 1. Interpolation of parameters
scen_RENBAL1 <- interpolate(add(mdl, STGBTR, DEM_ELC_DH), name = "RENBAL1", 
  description = "No inter-regional dispatch.")
summary(scen_RENBAL1)

# 2. Writing the model code and data in folder
write_model(scen_RENBAL1, tmp.dir = "solwork/scen_RENBAL1_py", solver = Pyomo)
# save(scen_RENBAL1, file = "tmp/scen_RENBAL1.RData")

# 3. Solving the model
solve_model(tmp.dir = "solwork/scen_RENBAL1_py", wait = F)

# 4. Read the solution (# after GAMS has finished)
if (F) { 
  if (!exists("scen_RENBAL1")) load("tmp/scen_RENBAL1.RData")
  summary(scen_RENBAL1)
  scen_RENBAL1py <- read_solution(scen_RENBAL1, dir.result = "solwork/scen_RENBAL1_py")
  summary(scen_RENBAL1py)
  
  save(scen_RENBAL1, file = "scenarios/scen_RENBAL1_py.RData")
  # load("scenarios/scen_RENBAL1.RData")
}

```

# Scenario 2: Exogenous UHV grid 100GW, endogenous converter stations 
~ 1h to solve
```{r scen_RENBAL2, eval=T}
# (optional) Scenario info:
{scen_descr <- "
India power sector, renewables balancing version,
30 regions, 1 hour resolution,
exogenous hourly demand,
3 types of renewables, 
1 types of storage,
no initial stock,
exogenous 100GW UHV grid between all regions,
converter stations."}

# 1. Interpolation of parameters
scen_RENBAL2 <- interpolate(
  add(mdl, STGBTR, UHV, TRBD_UHV_NEI_FX_CAP, ELC2UHV, UHV2ELC, DEM_ELC_DH), 
  name = "RENBAL2", description = scen_descr)

# 2. Writing the model code and data in folder
write_model(scen_RENBAL2, tmp.dir = "solwork/scen_RENBAL2", solver = GAMS)
# save(scen_RENBAL2, file = "tmp/scen_RENBAL2.RData")

# 3. Solving the model
solve_model(tmp.dir = "solwork/scen_RENBAL2", wait = F)
#
# 4. Read the solution
if (F) {
  if (!exists("scen_RENBAL2")) load("tmp/scen_RENBAL2.RData")
  summary(scen_RENBAL2)
  scen_RENBAL2 <- read_solution(scen_RENBAL2, dir.result = "solwork/scen_RENBAL2")
  summary(scen_RENBAL2)
  save(scen_RENBAL2, file = "scenarios/scen_RENBAL2.RData")
# load("scenarios/scen_RENBAL2.RData")
}

```

## Scenario 2a: Exogenous UHV grid 100GW (no capacity variable), endogenous converter stations
~ 1h to solve
```{r scen_RENBAL2a, eval=T}
# (optional) Scenario info:
{scen_descr <- "
India power sector, renewables balancing version,
30 regions, 1 hour resolution,
exogenous hourly demand,
3 types of renewables, 
1 types of storage,
no initial stock,
exogenous 100GW UHV grid between all regions,
converter stations."}

# 1. Interpolation of parameters
scen_RENBAL2a <- interpolate(
  add(mdl, STGBTR, UHV, TRBD_UHV_NEI_FX, ELC2UHV, UHV2ELC, DEM_ELC_DH), 
  name = "RENBAL2a", description = scen_descr)

# 2. Writing the model code and data in folder
write_model(scen_RENBAL2a, tmp.dir = "solwork/scen_RENBAL2a", solver = GAMS)
save(scen_RENBAL2a, file = "tmp/scen_RENBAL2a.RData")

# 3. Solving the model
solve_model(tmp.dir = "solwork/scen_RENBAL2a", wait = F)

# 4. Read the solution
if (F) {
  if (!exists("scen_RENBAL2a")) load("tmp/scen_RENBAL2a.RData")
  summary(scen_RENBAL2a)
  scen_RENBAL2a <- read_solution(scen_RENBAL2a, dir.result = "solwork/scen_RENBAL2a")
  summary(scen_RENBAL2a)
  save(scen_RENBAL2a, file = "scenarios/scen_RENBAL2a.RData")
# load("scenarios/scen_RENBAL2a.RData")
}

```

## Scenario 2b: Exogenous ELC grid 100GW, fixed capacity
~ 15 min to solve
```{r scen_RENBAL2b, eval=T}
# (optional) Scenario info:
{scen_descr <- "
India power sector, renewables balancing version,
30 regions, 1 hour resolution,
exogenous hourly demand,
3 types of renewables, 
1 types of storage,
no initial stock,
exogenous 100GW UHV grid between all regions,
converter stations."}

# 1. Interpolation of parameters
scen_RENBAL2b <- interpolate(
  add(mdl, STGBTR, TRBD_ELC_NEI_FX_CAP, DEM_ELC_DH), 
  name = "RENBAL2b", description = scen_descr)

# 2. Writing the model code and data in folder
write_model(scen_RENBAL2b, tmp.dir = "solwork/scen_RENBAL2b", solver = GAMS)
save(scen_RENBAL2b, file = "tmp/scen_RENBAL2b.RData")

# 3. Solving the model
solve_model(tmp.dir = "solwork/scen_RENBAL2b", wait = F)

# 4. Read the solution
if (F) {
  if (!exists("scen_RENBAL2b")) load("tmp/scen_RENBAL2b.RData")
  summary(scen_RENBAL2b)
  scen_RENBAL2b <- read_solution(scen_RENBAL2b, dir.result = "solwork/scen_RENBAL2b")
  summary(scen_RENBAL2b)
  save(scen_RENBAL2b, file = "scenarios/scen_RENBAL2b.RData")
# load("scenarios/scen_RENBAL2b.RData")
}

```


## Scenario 2c: Exogenous grid 100GW (no capacity variable) 
~ 11 min GAMS time
```{r scen_RENBAL2c, eval=T}
# (optional) Scenario info:
{scen_descr <- "
India power sector, renewables balancing version,
30 regions, 1 hour resolution,
exogenous hourly demand,
3 types of renewables, 
1 types of storage,
no initial stock,
exogenous 100GW UHV grid between all regions,
converter stations."}

# 1. Interpolation of parameters
scen_RENBAL2c <- interpolate(
  add(mdl, STGBTR, TRBD_ELC_NEI_FX, DEM_ELC_DH), 
  name = "RENBAL2c", description = scen_descr)

# 2. Writing the model code and data in folder
write_model(scen_RENBAL2c, tmp.dir = "solwork/scen_RENBAL2c", solver = GAMS)
save(scen_RENBAL2c, file = "tmp/scen_RENBAL2c.RData")

# 3. Solving the model
solve_model(tmp.dir = "solwork/scen_RENBAL2c", wait = F)

# 4. Read the solution
if (F) {
  if (!exists("scen_RENBAL2c")) load("tmp/scen_RENBAL2c.RData")
  summary(scen_RENBAL2c)
  scen_RENBAL2c <- read_solution(scen_RENBAL2c, dir.result = "solwork/scen_RENBAL2c")
  summary(scen_RENBAL2c)
  save(scen_RENBAL2c, file = "scenarios/scen_RENBAL2c.RData")
# load("scenarios/scen_RENBAL2c.RData")
}

```

# Scenario 3: Endogenous UHV grid and converter stations  
~ 8h GAMS time (full model)
```{r scen_RENBAL3, eval=T}
# (optional) Scenario info:
{scen_descr <- "
India power sector, balancing version,
30 regions, 1 hour resolution,
exogenous hourly demand,
3 types of renewables, 
1 types of storage,
no initial stock,
low ELC import price.
endogenous, unlimited UHV grid,
converter stations."}

# 1. Interpolation of parameters
scen_RENBAL3 <- interpolate(
  add(mdl, STGBTR, UHV, TRBD_UHV_NEI, ELC2UHV, UHV2ELC, DEM_ELC_DH), 
  name = "RENBAL3", description = scen_descr)
save(scen_RENBAL3, "tmp/scen_RENBAL3.RData")

# 2. Writing the model code and data in folder
write_model(scen_RENBAL3, tmp.dir = "solwork/scen_RENBAL3", solver = GAMS)

# 3. Solving the model
solve_model(tmp.dir = "solwork/scen_RENBAL3", wait = F)

# 4. Read the solution
if (F) {
  if (!exists("scen_RENBAL3")) load("tmp/scen_RENBAL3.RData")
  scen_RENBAL3 <- read_solution(scen_RENBAL3, dir.result = "solwork/scen_RENBAL3")
  summary(scen_RENBAL3)
  save(scen_RENBAL3, file = "scenarios/scen_RENBAL3.RData")
  # load("scenarios/scen_RENBAL3.RData")
}

```

## Solving with Python/Pyomo  
Solving the same scenario using Python/Pyomo with CBC or CPLEX, for comparison.
~ 30 min to generate 5-region model in Pyomo, ~ 7h CBC time or 10min CPLEX time
```{r scen_RENBAL3_py, eval=T}
Pyomo <- list(
  lang = "PYOMO",
  export_format = "SQLite",
  solver = "cplex"
  # solver = "cbc"
)

# (optional) Scenario info:
{scen_descr <- "
India power sector, balancing version,
30 regions, 1 hour resolution,
exogenous hourly demand,
3 types of renewables, 
1 types of storage,
no initial stock,
low ELC import price.
endogenous, unlimited UHV grid,
converter stations."}

# 1. Interpolation of parameters
scen_RENBAL3 <- interpolate(
  add(mdl, STGBTR, UHV, TRBD_UHV_NEI, ELC2UHV, UHV2ELC, DEM_ELC_DH), 
  name = "RENBAL3", description = scen_descr)
# save(scen_RENBAL3, "tmp/scen_RENBAL3_py.RData")

# 2. Writing the model code and data in folder
write_model(scen_RENBAL3, tmp.dir = "solwork/scen_RENBAL3_py", solver = Pyomo)

# 3. Solving the model
solve_model(tmp.dir = "solwork/scen_RENBAL3_py", wait = F)

# 4. Read the solution
if (F) {
  # if (!exists("scen_RENBAL3")) load("tmp/scen_RENBAL3.RData")
  scen_RENBAL3_py <- read_solution(scen_RENBAL3, dir.result = "solwork/scen_RENBAL3_py")
  summary(scen_RENBAL3_py)
  save(scen_RENBAL3_py, file = "scenarios/scen_RENBAL3.RData")
  # load("scenarios/scen_RENBAL3_py.RData")
}

```


# Scenario 4: Constraints on investments in UHV grid  
```{r scen_RENBAL4, eval=FALSE}
# Unrestricted (optimal) grid capacity from "RENBAL3"
msy <- mdl@sysInfo@milestone$mid

(vTradeCap <- getData(scen_RENBAL3, name = "vTradeCap", merge = T, year = max(msy),
                      newNames = c(value = "GW")))

trd_TWkm <- full_join(trd_dt, select(vTradeCap, trade, GW)) %>%
  mutate(TWkm = distance_km / 1e3 * GW)
sum(trd_TWkm$TWkm, na.rm = T) # TW*km

# Unrestricted (cost-optimal) grid investment
(vTradeInv <- getData(scen_RENBAL3, name = "vTradeInv", merge = T))
sum(vTradeInv$value) # 
sum(vTradeInv$value)/sum(trd_TWkm$TWkm, na.rm = T)

GRIDINV50 <- newConstraint(
  'GRIDINV50', eq = '<=', rhs = sum(vTradeInv$value)/2,
  variable = list(variable = 'vTradeInv'))

GRIDINV25 <- newConstraint(
  'GRIDINV25', eq = '<=', rhs = sum(vTradeInv$value)/4,
  variable = list(variable = 'vTradeInv'))

# 1. Interpolation of parameters
scen_RENBAL4 <- interpolate(
  add(mdl, UHV, TRBD_UHV_NEI, ELC2UHV, UHV2ELC, GRIDINV25, DEM_ELC_DH), 
  name = "RENBAL4")
save(scen_RENBAL4, file = "tmp/scen_RENBAL4_interpolated.RData")

# 2. Writing the model code and data in folder
write_model(scen_RENBAL4, tmp.dir = "solwork/scen_RENBAL4", solver = GAMS)

# 3. Solving the model
solve_model(tmp.dir = "solwork/RENBAL4", wait = FALSE)

# 4. Read the solution
if (F) {
  if (!exists("scen_RENBAL4")) load("tmp/scen_RENBAL4.RData")
  scen_RENBAL4 <- read_solution(scen_RENBAL4, dir.result = "solwork/scen_RENBAL4")
  summary(scen_RENBAL4)
  save(scen_RENBAL4, file = "scenarios/scen_RENBAL4.RData")
  # load("scenarios/scen_RENBAL4.RData")
}

```


# Scenario 5: flexible demand, fixed structure  
```{r scen_RENBAL5, eval=FALSE}
GRIDINV100BUSD <- newConstraint(
  'GRIDINV100BUSD', eq = '<=', rhs = 100e3, # 100 Billion USD
  variable = list(variable = 'vTradeInv'))

CSTGCAP1000 <- newConstraint(
  'CSTGCAP1K', eq = '<=', rhs = 1000, # GWh
  variable = list(variable = 'vStorageCap'))

{scen_descr <- "
INDEM, power sector, balancing version,
49 regions, 1 hour resolution,
3 types of renewables, 
1 type of storage,
3 (or 4) types of demand,
no initial stock,
endogenous UHV grid (neighbours matrix), limited investments to 50BUSD,
converter stations."}

# 1. Interpolation of parameters
scen_RENBAL5 <- interpolate(
  add(mdl, UHV, TRBD_UHV_NEI, ELC2UHV, UHV2ELC, 
      GRIDINV100BUSD, CSTGCAP1000,
      DEM100, ELC2DEM100, CELC2DEM100CAPFX, #CELC2DEM100CAPUP,
      DEM35, ELC2DEM35, CELC2DEM35CAPFX
      # DSMD, ELC2DSMD, DSMDEXP
      ), 
  name = "RENBAL5")
save(scen_RENBAL5, file = "tmp/scen_RENBAL5_interpolated.RData")

# 2. Writing the model code and data in folder
write_model(scen_RENBAL5, tmp.dir = "solwork/scen_RENBAL5", solver = GAMS)

# 3. Solving the model
solve_model(tmp.dir = "solwork/scen_RENBAL5", wait = FALSE)
# Alterntively, run GAMS directly in the model folder: 'gams mdl'

# 4. Read the solution
if (F) {
  if (!exists("scen_RENBAL5")) load("tmp/scen_RENBAL5_interpolated.RData")
  scen_RENBAL5 <- read_solution(scen_RENBAL5, dir.result = "solwork/scen_RENBAL5")
  summary(scen_RENBAL5)
  save("scenarios/scen_RENBAL5.RData")
  # load("scenarios/scen_RENBAL5.RData")
}

```

# Scenario 6: 3 levels of demand, endogenous structure, no trade, no storage  
```{r}

```

# Scenarion 7: 3 levels of demand, endogenous structure, fixed grid, limited storage  
```{r}

```

# Scenario 8: 
```{r}

```

# Scenario 9: 
```{r}

```


# Quick check
```{r}
# if (!exists("scen_RENBAL1")) load("scenarios/scen_RENBAL1.RData")
# if (!exists("scen_RENBAL2")) load("scenarios/scen_RENBAL2.RData")
if (!exists("scen_RENBAL3")) load("scenarios/scen_RENBAL3.RData")
# if (!exists("scen_RENBAL4")) load("scenarios/scen_RENBAL4.RData")
# if (!exists("scen_RENBAL5")) load("scenarios/scen_RENBAL5.RData")
# scen <- scen_RENBAL1
scen <- scen_INDEMBY
scen <- scen_RENBAL2
scen <- scen_RENBAL3
# scen <- scen_RENBAL4
# scen <- scen_RENBAL5

summary(scen)  
# Objective (system costs)
(vObjective <- getData(scen, name = "vObjective", merge = T))
# sum(pDemand_ELC$value)/1e3

# Price credit
# (vExp_Credit_ELC <- getData(scen, name = "vTradeCost", merge = T))
# 
# (vObj <- vObjective$value - sum(vExp_Credit_ELC$value))

# Total electricity output from generating technologies
(vTechOut_ELC <- getData(scen, name = "vTechOut", comm = "ELC", tech_ = "^E", 
                         merge = T))
unique(vTechOut_ELC$tech)
vTechOut_ELC %>%
  group_by(tech) %>% summarise(TWh = sum(value)/1e3)

# Total demand
# (vExportRow_ELC <- getData(scen, name = "vExport", comm = "DEMY", merge = T))
# sum(vExportRow_ELC$value)

(pDemand_ELC <- getData(scen, name = "pDemand", comm = "ELC", merge = T))
sum(pDemand_ELC$value)

(dem_tot <- sum(pDemand_ELC$value))

# Total ELC Output vs Demand
# sum(vTechOut_ELC$value) / dem_tot

# System costs USD/kWh (== MUSD/GWh)
## for electricity consumed
# vObj / dem_tot
# vObjective$value / sum(pDemand_ELC$value) / 3
## for electricity produced
# vObj / sum(vTechOut_ELC$value)

# Supply curtailments
(vExportROW_ELC <- getData(scen, name = "vExportRow", merge = T)) # if EEXP used
# sum(vExportROW_ELC$value)/dem_tot

(vBalance_ELC <- getData(scen, name = "vBalance", comm = c("ELC", "UHV"), merge = T)) 
sum(vBalance_ELC$value)/dem_tot * 100 # % of demand

(vBalance_CO2 <- getData(scen, name = "vBalance", comm = c("CO2"), merge = T)) %>%
  group_by(year, comm) %>%
  summarise(kt = sum(value))

# Demand curtailments
(vImportROW_ELC <- getData(scen, name = "vImportRow", merge = T)) 
sum(vImportROW_ELC$value)/dem_tot * 100 # %

# Generating and storage capacity 
getData(scen, name = c("vTechCap", "vStorageCap"), merge = T)

(vTechStgCap <- getData(scen, name = c("vTechCap", "vStorageCap"), merge = T, process = T))
vTechStgCap %>%
  group_by(scenario, process, year) %>%
  summarise(GW = sum(value))

vTechStgCap %>%
  group_by(region, process) %>%
  summarise(GW = round(sum(value))) %>%
  pivot_wider(names_from = process, values_from = GW) %>%
  left_join(reg_area) %>% select(-area_km2) %>%
  mutate(sol_max_GW = round(sol_max_GW), win_max_GW = round(win_max_GW)) %>%
  as.data.frame()

# Storage capacity
getData(scen, name = "vStorageCap", merge = T)
sum(getData(scen, name = "vStorageCap", merge = T)$value)
getData(scen, name = "vStorageCap", merge = T) %>%
  group_by(scenario, stg, region, year) %>%
  summarize(GW = sum(value))

# (vStorageCap_STGP2X <- getData(scen, name = "vStorageCap", merge = T, stg = "STGP2P"))
(vStorageCap_STGBTR <- getData(scen, name = "vStorageCap", merge = T, stg = "STGBTR"))
# sum(vStorageCap_STGP2X$value) # GWh - interdday (~seasonal) storage
sum(vStorageCap_STGBTR$value) # GWh - intraday (hourly) storage
sum(vStorageCap_STGBTR$value)/dem_tot * 100
# sum(vStorageCap_STGP2X$value)/dem_tot * 100

```

# Shape of supply
```{r}
(vTechOut_ELC <- getData(scen, name = "vTechOut", comm = "ELC", 
                         tech_ = "^E",
                         merge = T, newNames = c("value" = "GWh")))
summary(vTechOut_ELC$GWh)
unique(vTechOut_ELC$tech)
unique(vTechOut_ELC$year)

supy <- vTechOut_ELC %>%
  mutate(hour = as.integer(substr(slice, 7,8))) %>%
  group_by(scenario, year, hour, tech) %>%
  summarize(TWh = sum(GWh)/1e3) %>%
  mutate(tech = factor(tech, 
                       levels = c("ESOL", "EWFF", "EWIN"), 
                       ordered = T))

ggplot(supy) + 
  geom_area(aes(x = hour, y = TWh, fill = tech), stat = "identity") +
  labs(title = "Annual generation profile")


supm <- vTechOut_ELC %>%
  mutate(#hour = as.integer(substr(slice, 7,8)),
         month = month(as.Date ("2017-01-01") + as.integer(substr(slice, 2, 4)) - 1)) %>%
  mutate(month.name = factor(month.name[month], levels = month.name[1:12], ordered = T)) %>%
  group_by(scenario, year, month, month.name, tech) %>%
  summarize(TWh = sum(GWh)/1e3) %>%
  mutate(tech = factor(tech, 
                       levels = c("ESOL", "EWFF", "EWIN"), 
                       ordered = T))
ggplot(supm) + 
  geom_bar(aes(x = month.name, y = TWh, fill = tech), stat = "identity") 

```

# Demand structure
```{r}
# Export-based demand
DemStr <- getData(scen, name = c("vTechInp"), tech_ = "LOAD|DSM", comm = "ELC", 
                  merge = T, process = T)
unique(DemStr$process)

dem <- DemStr %>%
  mutate(hour = as.integer(substr(slice, 7,8))) %>%
  rename(GWh = value)


ii <- grepl("d101_", dem$slice)
# ii <- ii & grepl("NY", dem$region)
# ii <- ii & grepl("DEM100", dem$comm)

ggplot(dem[ii,]) +
  geom_bar(aes(x = hour, y = GWh, fill = process), stat = "identity") +
  # scale_y_continuous(trans = "log10") +
  facet_wrap(.~region, scales = "free_y")

demy <- dem %>%
  group_by(hour, process) %>%
  summarise(TWh = sum(GWh)/100)

ggplot(demy) +
  geom_area(aes(x = hour, y = TWh, fill = process), stat = "identity") 
  # scale_y_continuous(trans = "log10") +
  # facet_wrap(.~region, scales = "free_y")

demry <- dem %>%
  group_by(region, hour, process) %>%
  summarise(TWh = sum(GWh)/100)

ggplot(demry) +
  geom_area(aes(x = hour, y = TWh/1000, fill = process), stat = "identity") +
  # scale_y_continuous(trans = "log10") +
  # facet_wrap(.~region)
  facet_wrap(.~region, scales = "free_y")


demmh <- dem %>%
  mutate(hour = as.integer(substr(slice, 7,8)),
         month = month(as.Date ("2050-01-01") + as.integer(substr(slice, 2, 4)) - 1)) %>%
  mutate(month.name = factor(month.name[month], levels = month.name[1:12], ordered = T)) %>%
  group_by(scenario, year, hour, month.name, process) %>%
  summarize(TWh = sum(GWh)/1e3) #%>%
demmh

ggplot(demmh) +
  geom_area(aes(x = hour, y = TWh, fill = process), stat = "identity") +
  # scale_y_continuous(trans = "log10") +
  facet_wrap(.~month.name, nrow = 4)

demmy <- dem %>%
  mutate(hour = as.integer(substr(slice, 7,8)),
         month = month(as.Date ("2050-01-01") + as.integer(substr(slice, 2, 4)) - 1)) %>%
  mutate(month.name = factor(month.name[month], levels = month.name[1:12], ordered = T)) %>%
  mutate(month.abb = factor(month.abb[month], levels = month.abb[1:12], ordered = T)) %>%
  group_by(scenario, year, month, month.abb, month.name, process) %>%
  summarize(TWh = sum(GWh)/1e3) #%>%
demmy

ggplot(demmy) +
  geom_bar(aes(x = month.abb, y = TWh, fill = process), stat = "identity") 
  # scale_y_continuous(trans = "log10") +
  # facet_wrap(.~month.name, nrow = 4)

ggplot(demmy) +
  geom_area(aes(x = month, y = TWh, fill = process), stat = "identity") +
  scale_x_continuous(breaks = 1:12, labels = 1:12)

```


# Capacity maps
```{r Capacity_maps}
vCap <- getData(scen, name = c("vTechCap", "vStorageCap"), merge = T, process = T)

lev <- unique(vCap$process)
vCap$process <- factor(vCap$process, levels = lev, ordered = T)

# Technologies capacity
ggplot(data = gis_df) + 
  geom_polygon(aes(x = long, y = lat, group = group), fill = "grey85", 
                   colour = "white", alpha = 1, size = .5) +
    geom_polygon(aes(x = long, y = lat, group = group, fill = value),
                     data = right_join(gis_df, vCap, by = c("id" = "region")), #fill = "wheat", 
                 color = "white", alpha = 1, size = 0.25, inherit.aes = F) + # aes fill = id, 
  coord_fixed(1.0) +
  theme_void() +
  # scale_fill_distiller(palette = "Spectral", direction = -1, name = "GW") +
  scale_fill_distiller(palette = "Spectral", direction = -1, trans = "log10", name = "GW") +
  labs(title = "Installed technologies") +
  theme(plot.title = element_text(hjust = 0.5), 
        plot.subtitle = element_text(hjust = 0.5)) +
  facet_wrap(.~process, ncol = 2)

```

# Storage operation
```{r }
# getData(scen, name_ = "vStorage")

# (vStorageInp_STGP2P <- getData(scen, name = "vStorageInp", merge = T, stg = "STGP2P"))
# max(vStorageInp_STGP2P$value)

(vSTGBTR <- getData(scen, 
          name = c("vStorageInp", "vStorageOut", "vStorageStore"),
          merge = T, stg = "STGBTR", slice_ = "d10[1-2]", region = reg_names[1]))

ggplot(vSTGBTR) + 
  geom_bar(aes(x = slice, y = value, fill = name), stat = "identity") +
  theme(axis.text.x = element_text(angle = 90))

tSTGBTR <- vSTGBTR %>%
  spread(key = name, value = value)

summary(tSTGBTR$vStorageInp)
summary(tSTGBTR$vStorageOut)
summary(tSTGBTR$vStorageStore)


# (vSTGP2P <- getData(scen, 
#           name = c("vStorageInp", "vStorageOut", "vStorageStore"),
#           merge = T, stg = "STGP2P", slice_ = "d01", region = "ND"))
# 
# ggplot(vSTGP2P) + 
#   geom_bar(aes(x = slice, y = value, fill = name), stat = "identity") +
#   # theme_void() +
#   theme(axis.text.x = element_text(angle = 90))
#   

```


# Trade flows maps
```{r Trade flows}
scen@name
trdIr <- getData(scen, name = "vTradeIr", merge = T)
summary(trdIr$value)
# summary(convert("PJ", "GWh", trdIr$value))
trdIr[which(trdIr$value == max(trdIr$value)), ]
tt <- sort(unique(trdIr$trade))
tt

trdIr_year <- trdIr %>%
  group_by(src, dst, year) %>%
  # summarize(TWh = convert("PJ", "TWh", sum(value)))
  summarize(
    GW = max(value),
    GWh = sum(value))
trdIr_year

trd_elc_y <- trdIr_year %>%
  left_join(reg_centers, by = c("src" = "region")) %>%
  rename(xsrc = x, ysrc = y) %>%
  left_join(reg_centers, by = c("dst" = "region")) %>%
  rename(xdst = x, ydst = y) 


# trd_elc_y <- left_join(trdIr_year, trd_map)
summary(trd_elc_y$GWh)/24/365
summary(trd_elc_y$GW)
trd_elc_y[is.na(trd_elc_y$GWh),]

# trd_flows_map
trd_flows_map2 <-
ggplot(data = gis_df) + 
    geom_polygon(aes(x = long, y = lat, group = group), fill = "wheat", 
                 colour = "white", alpha = 1, size = .5) + # aes fill = id, 
    coord_fixed(1.0) +
    guides(fill=FALSE) +  # do this to leave off the color legend
    theme_void() + labs(title = "Annual electricity trade flows")  + 
    theme(plot.title = element_text(hjust = 0.5), 
          plot.subtitle = element_text(hjust = 0.5)) +
    geom_segment(aes(x=xsrc, y=ysrc, xend=xdst, yend=ydst, size = GWh/1e3), 
    # geom_segment(aes(x=xsrc, y=ysrc, xend=xdst, yend=ydst, size = GWh/1e3), 
    # geom_segment(aes(x=xsrc, y=ysrc, xend=xdst, yend=ydst, size = GWh/1e2/8760), 
                 data = trd_elc_y, inherit.aes = FALSE, #size = 3, 
                 alpha = 1, colour = "dodgerblue", lineend = "round", show.legend = T) +
    scale_size_continuous(name = "TWh") +
    geom_point(data = reg_centers, aes(x, y), colour = "red") +
    geom_segment(aes(x=xsrc, y=ysrc, xend=xdst, yend=ydst), 
                 data = trd_elc_y, inherit.aes = FALSE, size = .1, 
             arrow = arrow(type = "closed", angle = 15, 
                           length = unit(0.15, "inches")),
             colour = "white", alpha = 0.75, 
             lineend = "butt", linejoin = "mitre", show.legend = T)

trd_flows_map2
# cowplot::plot_grid(trd_flows_map, trd_flows_map2)



```

# Grid capacity
```{r Grid_cap}
scen@name
vTradeCap <- getData(scen, name = "vTradeCap", merge = T, newNames = c("value" = "GW"))
summary(vTradeCap$GW)
# summary(convert("PJ", "GWh", trdIr$value))
# vTradeCap[which(vTradeCap$GW == max(vTradeCap$GW)), ]

vTradeInv <- getData(scen, "vTradeInv", merge = T)
sum(vTradeInv$value)

# getData(scen, name_ = "pTrade", merge = F)
getData(scen, name = "vTradeNewCap")

vTradeCap <- vTradeCap %>%
  full_join(trd_dt) %>%
  left_join(reg_centers, by = c("src" = "region")) %>%
  rename(xsrc = x, ysrc = y) %>%
  left_join(reg_centers, by = c("dst" = "region")) %>%
  rename(xdst = x, ydst = y) 
    

ii <- vTradeCap$GW >= 0 # filter grid capacity if needed

trd_cap_map <-
ggplot(data = gis_df) + 
  geom_polygon(aes(x = long, y = lat, group = group), fill = "wheat", 
               colour = "white", alpha = 1, size = .5) + # aes fill = id, 
  coord_fixed(1.) +
  guides(fill=FALSE) +  # do this to leave off the color legend
  theme_void() + labs(title = "Optimized UHV grid capacity")  + 
  theme(plot.title = element_text(hjust = 0.5), 
        plot.subtitle = element_text(hjust = 0.5)) +
  geom_segment(aes(x=xsrc, y=ysrc, xend=xdst, yend=ydst, size = GW), 
  # geom_segment(aes(x=xsrc, y=ysrc, xend=xdst, yend=ydst, size = GWh/1e3), 
  # geom_segment(aes(x=xsrc, y=ysrc, xend=xdst, yend=ydst, size = GWh/1e2/8760), 
               data = vTradeCap[ii,], inherit.aes = FALSE, #size = 3, 
               alpha = 1, colour = "dodgerblue", lineend = "round", show.legend = T) +
  scale_size_continuous(range = c(1, 5)) +
  geom_segment(aes(x=xsrc, y=ysrc, xend=xdst, yend=ydst), 
               data = vTradeCap[ii,], inherit.aes = FALSE, size = .1, 
           # arrow = arrow(type = "closed", angle = 15, 
           #               length = unit(0.15, "inches")),
           colour = "white", alpha = 0.75, 
           lineend = "butt", linejoin = "mitre", show.legend = T) +
  geom_point(data = reg_centers, aes(x, y), colour = "white")
trd_cap_map

# plot_grid(trd_cap_map, trd_flows_map2)

```

